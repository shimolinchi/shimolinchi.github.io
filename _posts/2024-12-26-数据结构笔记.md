---
layout:     post
title:      数据结构笔记
subtitle:   
date:       2024-12-26
author:     试墨临池
header-img: img/post-data.jpg
catalog: true
tags:
    - 数据结构
---


## 数组、向量和链表

### 数组
在C和C++中都学过，因此不细写。回忆一种数组动态分配内存方法
```C++
char* a;
a = new char[5];
```
和
```
char a[5];
```
这两种方法区别是

特性|char* a; a = new char[5];|char a[5];
内存分配位置|堆（heap）|栈（stack）
内存管理|需要手动 delete[] 释放|自动释放，当作用域结束时
数组大小|运行时决定，可以动态调整大小|编译时决定，固定大小
内存访问速度|相对较慢，受限于堆的管理开销|更快，栈内存访问速度较快
初始化|不会自动初始化，需要显式初始化|默认初始化（局部变量是未定义的）
生命周期|程序员控制，必须手动释放内存|与作用域绑定，超出作用域自动销毁

### 向量

向量本质上与数组无异，C++标准库中新增了一些功能，如向向量后方添加一个元素
```C++
push_back();
```
去掉最后一个元素
```C++
pop_back();
```
清除、插入中间的元素
```C++
vec.erase(vec.begin()+1);
vec.insert(vec.end(), 1, 'a');
```
这种方法比较慢，因为时间复杂度为$O_{(n)}$

### 链表

C++中链表的元素访问不能通过方括号访问，需要一个迭代器iterator，具体方法如下
```C++
list<char>::iterator iter = list.begin();
cout << *iter;
```
同样链表中也有push_back、push_front、pop_back、pop_front等用法，功能顾名思义。
## 二分查找

主要思想是先取中间值、与目标值比较、取中间值、比较，以此类推....

## 跳跃链表

### 跳跃链表的结构
假设一个单向链表，在每个节点上方都增加了若干层L1、L2、L3...第二层中，对于每一个节点，有二分之一概率会将第一层向上增加到第二层。第三层则是增加到第二层的节点有二分之一概率从第二层增加到第三层，以此类推，这样形成的链表即时跳跃链表
![](https://raw.githubusercontent.com/shimolinchi/shimolinchi.github.io/master/img/2024-12-26数据结构笔记/1.png)
跳跃链表牺牲了空间换取时间，因此相较于普通链表可以快速到达中间节点。
推荐层数选为n因为这样查找和插入的时间复杂度都是$O_{log(n)}$?

### 跳跃链表的查找

跳跃链表查找数据首先从最高的层开始。首先将目标数据与sentinel节点和其在最高层指向的下一节点的数据相比较，在哪个区间便在进入下一层时取哪个数据段，以此类推。

### 跳跃链表的插入

从sentinel开始，将其作为基准节点，跳跃链表的插入首先找到目标节点的左右两边节点，然后像普通链表一样插入。接着从第二层开始判断是否增加到下一层，若增加，则将该层的连接处指针进行调换，直到插入的节点不增加层数

## 矩阵

+ Dense matrix：稠密矩阵，大部分是非0元素

+ Sparse matrix：稀疏矩阵，非0元素远远小于总元素数

### 矩阵的存储

+ 按行存储：将矩阵每一行按顺序存储到一个数组中
+ 按列存储：将矩阵每一列按顺序存储到一个数组中

**区别**：对于行存储，按行访问的速度快，按列访问速度慢（空间的局部性）

## 图

图是由节点、边组成的数据结构

![](https://raw.githubusercontent.com/shimolinchi/shimolinchi.github.io/master/img/2024-12-26数据结构笔记/2.png)

+ **有向图**存在边是单向的
+ **无向图**所有边都是双向的
+ **有权图**边存在权重
+ **无权图**边的权重全部相等

邻接表
![](https://raw.githubusercontent.com/shimolinchi/shimolinchi.github.io/master/img/2024-12-26数据结构笔记/3.png)

邻接矩阵
![](https://raw.githubusercontent.com/shimolinchi/shimolinchi.github.io/master/img/2024-12-26数据结构笔记/4.png)

邻接表和邻接矩阵都是描述图的一种数据结构。当图是无向的，邻接矩阵对称，反之不对称。当图是无权的，图的所有边相等，都以1表示，反之则不相等。

### 路径

路径可以表示为节点的序列，从路径的起点到终点组成的序列，也可以表示为边的序列

对于无权图，路径的长度是边的序列长度；对于有权图，路径的长度要考虑权重（路径上的长度加和）

**简单路径**：路径不会绕圈

**最短路径**：输入图$G=(\nu,\epsilon)$和起点s，任务是找到从起点s出发的长度最短路径

### 单元最短路问题

通过下图这样一个表，可以获得以s为起点（图中为$v_3$）的最短路。因此单元最短路问题就是得到这样一个表。

![](https://raw.githubusercontent.com/shimolinchi/shimolinchi.github.io/master/img/2024-12-26数据结构笔记/5.png)

### 无权图中的最短路

准备工作：准备一个队列（先入先出），和一个表（初始值如下）
![](https://raw.githubusercontent.com/shimolinchi/shimolinchi.github.io/master/img/2024-12-26数据结构笔记/6.png)

其中，visit代表是否经过该节点，dist代表路径长度，path用来记录路径。

初始时，将起点（$v_3$）放入队列中，准备工作完成

![](https://raw.githubusercontent.com/shimolinchi/shimolinchi.github.io/master/img/2024-12-26数据结构笔记/7.png)

一轮循环：开始时，先检查队列。由于$v_3$在最前列，把$v_3$取出。然后处理$v_3$指向的$v_1$和$v_6$。

    处理$v_1$：由于含$v_1$的一行visit为no，即没有被处理过（若处理过则直接跳过），因此将visit标注为yes，dist标记为$v_3$到$v_1$的路径长度1，记录$v_1$的path为$v_3$。
![](https://raw.githubusercontent.com/shimolinchi/shimolinchi.github.io/master/img/2024-12-26数据结构笔记/8.png)

    处理$v_6$：与处理$v_1$相同。此时队列中有两个元素$v_1$和$v_6$。

二轮循环：由于队列最前端是$v_1$，$v_1$通向$v_2$和$v_4$，由于没有被处理过，因此处理$v_2$和$v_4$。$v_2$的dist为2，path为$v_1$。然后处理$v_6$，由于$v_6$没有指向的节点，因此仅从队列中取出，循环结束

三轮循环：从队列顶端取出$v_2$，其指向$v_4$和$v_5$，由于$v_4$被访问过，因此跳过，然后处理$v_5$。

后面的循环以此类推

算法的时间复杂度为$O_{(\nu+\epsilon)}$


