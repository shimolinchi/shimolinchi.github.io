---
layout:     post
title:      数据结构笔记
subtitle:   
date:       2024-12-26
author:     试墨临池
header-img: img/post-data.jepg
catalog: true
tags:
    - 数据结构
---


## 数组、向量和链表

### 数组
在C和C++中都学过，因此不细写。回忆一种数组动态分配内存方法
```C++
char* a;
a = new char[5];
```
和
```
char a[5];
```
这两种方法区别是

特性|char* a; a = new char[5];|char a[5];
内存分配位置|堆（heap）|栈（stack）
内存管理|需要手动 delete[] 释放|自动释放，当作用域结束时
数组大小|运行时决定，可以动态调整大小|编译时决定，固定大小
内存访问速度|相对较慢，受限于堆的管理开销|更快，栈内存访问速度较快
初始化|不会自动初始化，需要显式初始化|默认初始化（局部变量是未定义的）
生命周期|程序员控制，必须手动释放内存|与作用域绑定，超出作用域自动销毁

### 向量

向量本质上与数组无异，C++标准库中新增了一些功能，如向向量后方添加一个元素
```C++
push_back();
```
去掉最后一个元素
```C++
pop_back();
```
清除、插入中间的元素
```C++
vec.erase(vec.begin()+1);
vec.insert(vec.end(), 1, 'a');
```
这种方法比较慢，因为时间复杂度为$O_{(n)}$

### 链表

C++中链表的元素访问不能通过方括号访问，需要一个迭代器iterator，具体方法如下
```C++
list<char>::iterator iter = list.begin();
cout << *iter;
```
同样链表中也有push_back、push_front、pop_back、pop_front等用法，功能顾名思义。
## 二分查找

主要思想是先取中间值、与目标值比较、取中间值、比较，以此类推....

## 跳跃链表

### 跳跃链表的结构
假设一个单向链表，在每个节点上方都增加了若干层L1、L2、L3...第二层中，对于每一个节点，有二分之一概率会将第一层向上增加到第二层。第三层则是增加到第二层的节点有二分之一概率从第二层增加到第三层，以此类推，这样形成的链表即时跳跃链表
![](https://raw.githubusercontent.com/shimolinchi/shimolinchi.github.io/master/img/2024-12-26数据结构笔记/1.png)
跳跃链表牺牲了空间换取时间，因此相较于普通链表可以快速到达中间节点。
推荐层数选为n因为这样查找和插入的时间复杂度都是$O_{log(n)}$?

### 跳跃链表的查找

跳跃链表查找数据首先从最高的层开始。首先将目标数据与sentinel节点和其在最高层指向的下一节点的数据相比较，在哪个区间便在进入下一层时取哪个数据段，以此类推。

### 跳跃链表的插入

从sentinel开始，将其作为基准节点，跳跃链表的插入首先找到目标节点的左右两边节点，然后像普通链表一样插入。接着从第二层开始判断是否增加到下一层，若增加，则将该层的连接处指针进行调换，直到插入的节点不增加层数

## 矩阵

+ Dense matrix：稠密矩阵，大部分是非0元素

+ Sparse matrix：稀疏矩阵，非0元素远远小于总元素数

### 矩阵的存储

+ 按行存储：将矩阵每一行按顺序存储到一个数组中
+ 按列存储：将矩阵每一列按顺序存储到一个数组中

**区别**：对于行存储，按行访问的速度快，按列访问速度慢（空间的局部性）

## 图

图是由节点、边组成的数据结构

![](https://raw.githubusercontent.com/shimolinchi/shimolinchi.github.io/master/img/2024-12-26数据结构笔记/2.png)

+ **有向图**：存在边是单向的
+ **无向图**：所有边都是双向的
+ **有权图**：边存在权重
+ **无权图**：边的权重全部相等

邻接表
![](https://raw.githubusercontent.com/shimolinchi/shimolinchi.github.io/master/img/2024-12-26数据结构笔记/3.png)

邻接矩阵
![](https://raw.githubusercontent.com/shimolinchi/shimolinchi.github.io/master/img/2024-12-26数据结构笔记/4.png)

邻接表和邻接矩阵都是描述图的一种数据结构。当图是无向的，邻接矩阵对称，反之不对称。当图是无权的，图的所有边相等，都以1表示，反之则不相等。

### 路径

路径可以表示为节点的序列，从路径的起点到终点组成的序列，也可以表示为边的序列

对于无权图，路径的长度是边的序列长度；对于有权图，路径的长度要考虑权重（路径上的长度加和）

**简单路径**：路径不会绕圈

**最短路径**：输入图$G=(\nu,\epsilon)$和起点s，任务是找到从起点s出发的长度最短路径

### 单元最短路问题

通过下图这样一个表，可以获得以s为起点（图中为$v_3$）的最短路。因此单元最短路问题就是得到这样一个表。

![](https://raw.githubusercontent.com/shimolinchi/shimolinchi.github.io/master/img/2024-12-26数据结构笔记/5.png){: width="70%" height="70%"}

### 无权图中的最短路

准备工作：准备一个队列（先入先出），和一个表（初始值如下）
![](https://raw.githubusercontent.com/shimolinchi/shimolinchi.github.io/master/img/2024-12-26数据结构笔记/6.png){: width="60%" height="60%"}

其中，visit代表是否经过该节点，dist代表路径长度，path用来记录路径。

初始时，将起点（$v_3$）放入队列中，准备工作完成

![](https://raw.githubusercontent.com/shimolinchi/shimolinchi.github.io/master/img/2024-12-26数据结构笔记/7.png){: width="70%" height="70%"}

一轮循环：开始时，先检查队列。由于$v_3$在最前列，把$v_3$取出。然后处理$v_3$指向的$v_1$和$v_6$。

处理$v_1$：由于含$v_1$的一行visit为no，即没有被处理过（若处理过则直接跳过），因此将visit标注为yes，dist标记为$v_3$到$v_1$的路径长度1，记录$v_1$的path为$v_3$。
![](https://raw.githubusercontent.com/shimolinchi/shimolinchi.github.io/master/img/2024-12-26数据结构笔记/8.png)
处理$v_6$：与处理$v_1$相同。此时队列中有两个元素$v_1$和$v_6$。

二轮循环：由于队列最前端是$v_1$，$v_1$通向$v_2$和$v_4$，由于没有被处理过，因此处理$v_2$和$v_4$。$v_2$的dist为2，path为$v_1$。然后处理$v_6$，由于$v_6$没有指向的节点，因此仅从队列中取出，循环结束

三轮循环：从队列顶端取出$v_2$，其指向$v_4$和$v_5$，由于$v_4$被访问过，因此跳过，然后处理$v_5$。

后面的循环以此类推

![](https://raw.githubusercontent.com/shimolinchi/shimolinchi.github.io/master/img/2024-12-26数据结构笔记/9.png){: width="60%" height="60%"}

算法的时间复杂度为$O_{(\nu+\epsilon)}$

### 无权图中的最短路（Dijkstra算法）

![](https://raw.githubusercontent.com/shimolinchi/shimolinchi.github.io/master/img/2024-12-26数据结构笔记/10.png){: width="60%" height="60%"}

该算法需要一个优先队列，即哪个节点距离初始节点（$v_3$）最近，哪个节点先出队列。
准备一个优先队列和一个表如下图：
![](https://raw.githubusercontent.com/shimolinchi/shimolinchi.github.io/master/img/2024-12-26数据结构笔记/11.png)

由于距离初始都是正无穷，因此对于途径某一个节点，距离小于当前距离即需要进行更新（大于则直接忽略），并且更新后的节点需要根据优先级插入队列（距离越小优先级越高）。

一轮循环：取出队列中的$v_3$，找到$v_3$指向的两个节点$v_1$和$v_6$，更新表中的距离和路径。对于$v_1$，dist=4，path=$v_3$。
然后更新$v_6$的路径，将dist=5，path=$v_3$，将$v_1$和，并将$v_1$和$v_6$插入队列

二轮循环：取出队列中的$v_1$，找到其指向的节点$v_2$和$v_4$。更新表中的$v_2$和$v_4$。更新了则插入队列，未更新就跳过。

之后的循环以此类推

算法的时间复杂度为$O_{((\| \nu\|+\|\epsilon\|)\cdot log\|\nu\|)}$

## 最小生成树

树是特殊的图。一个图满足三个条件即是树：
+ 连通的
+ 无环的
+ 无向的

有n个节点的树一定有n-1个节点

生成树（Spanning Trees）指的是保留全部的节点和一部分边的子图，并满足树的要求。

最小生成树指的是生成树中所有边权重和最小的。

### Prim算法

算法输入：一张无向有权图。

![](https://raw.githubusercontent.com/shimolinchi/shimolinchi.github.io/master/img/2024-12-26数据结构笔记/12.png)

一轮循环：首先随机找一个节点，假定为$v_1$，将其加入到集合U中。

二轮循环：找到$v_1$连接的点中边的权重最小的节点$v_4$，将其加入到U中

三轮循环：找到U中包含节点所连接的点中边的权重最小的节点$v_2$（$v_3$与之相等，取哪个都可以），将其加入到U中

四轮循环：找到U中包含节点所连接的点中边的权重最小的节点$v_3$，将其加入到U中

以此类推，由于在加入U的过程中始终保持连通性和无环性两个性质，因此当所有节点都被加入到U中时，即找到了最小生成树。

### Kruskal算法

该算法的思想是维持一个森林，包含着很多树

算法输入：一张无向有权图。

准备操作：创建一个队列，存储所有的边，队列按照边的权重做排序。用T表示被选中的边

![](https://raw.githubusercontent.com/shimolinchi/shimolinchi.github.io/master/img/2024-12-26数据结构笔记/13.png)

一轮循环：从队列中退出权重最小的边（1，4），判断$v_1$和$v_4$是否在同一棵树中（即是否通过已经在T中的边相连），不在则放入T中。

二轮循环：从队列中退出权重最小的边（6，7），$v_6$和$v_7$不在同一棵树中，因此放入T中。

三轮循环：从队列中退出权重最小的边（1，2），$v_1$和$v_2$不在同一棵树中，因此放入T中

以此类推，由于在边的遍历过程始终判断是否通过已经在T中的边相连（即保持了无环性），因此当选中的边数量为n-1（连通性）之后，即找到了最小生成树。

+ 判断两个节点是否在同一颗树中：使用并查集，将每一次边的加入都进行一次节点集合的分类
![](https://raw.githubusercontent.com/shimolinchi/shimolinchi.github.io/master/img/2024-12-26数据结构笔记/14.png)

算法的时间复杂度为$O_{(m\cdot log m)}+m\cdot O_{(1)}$，m为边的数量