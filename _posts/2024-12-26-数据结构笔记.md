---
layout:     post
title:      数据结构笔记
subtitle:   
date:       2024-12-26
author:     试墨临池
header-img: img/post-data.jpg
catalog: true
tags:
    - 数据结构
---


## 数组、向量和链表

### 数组
在C和C++中都学过，因此不细写。回忆一种数组动态分配内存方法
```C++
char* a;
a = new char[5];
```
和
```
char a[5];
```
这两种方法区别是

特性|char* a; a = new char[5];|char a[5];
内存分配位置|堆（heap）|栈（stack）
内存管理|需要手动 delete[] 释放|自动释放，当作用域结束时
数组大小|运行时决定，可以动态调整大小|编译时决定，固定大小
内存访问速度|相对较慢，受限于堆的管理开销|更快，栈内存访问速度较快
初始化|不会自动初始化，需要显式初始化|默认初始化（局部变量是未定义的）
生命周期|程序员控制，必须手动释放内存|与作用域绑定，超出作用域自动销毁

### 向量

向量本质上与数组无异，C++标准库中新增了一些功能，如向向量后方添加一个元素
```C++
push_back();
```
去掉最后一个元素
```C++
pop_back();
```
清除、插入中间的元素
```C++
vec.erase(vec.begin()+1);
vec.insert(vec.end(), 1, 'a');
```
这种方法比较慢，因为时间复杂度为$O_{(n)}$

### 链表

C++中链表的元素访问不能通过方括号访问，需要一个迭代器iterator，具体方法如下
```C++
list<char>::iterator iter = list.begin();
cout << *iter;
```
同样链表中也有push_back、push_front、pop_back、pop_front等用法，功能顾名思义。
## 二分查找

主要思想是先取中间值、与目标值比较、取中间值、比较，以此类推....

## 跳跃链表

### 跳跃链表的结构
假设一个单向链表，在每个节点上方都增加了若干层L1、L2、L3...第二层中，对于每一个节点，有二分之一概率会将第一层向上增加到第二层。第三层则是增加到第二层的节点有二分之一概率从第二层增加到第三层，以此类推，这样形成的链表即时跳跃链表
![](https://raw.githubusercontent.com/shimolinchi/shimolinchi.github.io/master/img/2024-12-26数据结构笔记/1.png)
跳跃链表牺牲了空间换取时间，因此相较于普通链表可以快速到达中间节点。
推荐层数选为n因为这样查找和插入的时间复杂度都是$O_{log(n)}$?

### 跳跃链表的查找

跳跃链表查找数据首先从最高的层开始。首先将目标数据与sentinel节点和其在最高层指向的下一节点的数据相比较，在哪个区间便在进入下一层时取哪个数据段，以此类推。

### 跳跃链表的插入

从sentinel开始，将其作为基准节点，跳跃链表的插入首先找到目标节点的左右两边节点，然后像普通链表一样插入。接着从第二层开始判断是否增加到下一层，若增加，则将该层的连接处指针进行调换，直到插入的节点不增加层数

## 矩阵

+ Dense matrix：稠密矩阵，大部分是非0元素

+ Sparse matrix：稀疏矩阵，非0元素远远小于总元素数

### 矩阵的存储

+ 按行存储：将矩阵每一行按顺序存储到一个数组中
+ 按列存储：将矩阵每一列按顺序存储到一个数组中

**区别**：对于行存储，按行访问的速度快，按列访问速度慢（空间的局部性）

## 图

图是由节点、边组成的数据结构

![](https://raw.githubusercontent.com/shimolinchi/shimolinchi.github.io/master/img/2024-12-26数据结构笔记/2.png)

+ **有向图**存在边是单向的
+ **无向图**所有边都是双向的
+ **有权图**边存在权重
+ **无权图**边的权重全部相等

邻接表
![](https://raw.githubusercontent.com/shimolinchi/shimolinchi.github.io/master/img/2024-12-26数据结构笔记/3.png)

邻接矩阵
![](https://raw.githubusercontent.com/shimolinchi/shimolinchi.github.io/master/img/2024-12-26数据结构笔记/4.png)

邻接表和邻接矩阵都是描述图的一种数据结构。当图是无向的，邻接矩阵对称，反之不对称。当图是无权的，图的所有边相等，都以1表示，反之则不相等。